How 2 minecraft mod the text document: //todo: make in markdown cuz fancy formats

First go get urself a nice forge mdk from http://files.minecraftforge.net/
then extract it into a folder somewhere

Then delete everything deleted in this commit right here:
https://github.com/Shadows-of-Fire/How2Mod/commit/d55fbaa0f6d84c91f5114053fa302e4da9bcb0f7

Now you need to go actually get the gradle wrapper again, since you just deleted 2.14 (the very old version forge ships)
https://gradle.org/releases/ Go get yourself the binary-only edition of the latest gradle.
Since this is the actual version of gradle, you'll need to do a few things to use it.

You have two options here: Either install gradle to your system, or temporarily extract and generate the wrapper files.

Since the second option is less compilated, let's go with that.

So extract the gradle zip into some folder, then run the command "gradle w" from a command prompt or command line.
then run "gradle --stop" to close the daemon so you can delete this folder later.
Now you have generated 4 files you need to go put the wrapper back in your forge workspace.

gradlew
gradlew.bat
gradle (folder)

Move those three things into the dir with your mdk and then we can get back to that. (you can then delete the old gradle folder). See commit: https://github.com/Shadows-of-Fire/How2Mod/commit/e4ba4e1b92751816d7267780b8f84b759cc2757b

Then if you want a bit of understanding about the build.gradle, I've changed the default comments on them because they are useless. https://github.com/Shadows-of-Fire/How2Mod/blob/8b52990a88a6318e68a43d540754ff70ce5218a9/build.gradle

Now, there are a few things you need for this (one of them is a JDK, the other is an IDE).
If you dont have a JDK, you need to install it and properly configure it.
http://www.oracle.com/technetwork/java/javase/downloads/index.html
(I won't be going over that)
If you don't have an IDE, you need to go get one.  The only "supported" ones are IntelliJ IDEA and Eclipse.
I use eclipse, but this is a preference thing, so it really doesn't matter.
https://www.jetbrains.com/idea/download/ <- IntelliJ IDEA
https://www.eclipse.org/downloads/ <- Eclipse (giant Download 64 Bit button)

So now you have all those things you can actually start making a mod woo nice job
Back to the forge folder and run the command "gradlew sDecW eclipse" (for eclipse) or "gradlew sDecW idea" (for IDEA).
sDecW means setupDecompWorkspace (it's literally just the shorter command version, either works) and the second command makes certain IDE files.
sDecW will take a while, so just sit there and let it do stuff.  If it fails, it probably means your JDK is improperly configured.  The whole process is that this command downloads forge, the mappings, and minecraft.  It then decompiles minecraft, deobfuscates it (remaps most of the method and field names into readable ones), and then recompiles it so it can run in a dev environment, and creates a linked source jar for you to work with.  It's basically all magic.

Now here's the part where its important that I use eclipse, because if you're using IDEA, you'll have to figure out the idea equivalent of certain things I do.  *anyway* lets begin.

Now that your sDecW is finished (you should see a BUILD SUCCESSFUL) in the command window, you need to import the project into your IDE.  I think i'm gonna start using newlines here to split Eclipse and IDEA, in case anyone wants to write in here how that works.

ECLIPSE:  
	First, use the help menu to open the eclipse marketplace and install the Buildship plugin.
	Use the import function and import an Existing Gradle Project.  Then just direct it to the folder containing your build.gradle and hit finish. Then you should end up with this: https://imgur.com/KLCwWmu

IDEA: Idea should have an import function for this, and it handles gradle on its own.

So now we basically just have the example mod in here. (com.example.examplemod.ExampleMod)
Which you can work with easily, but you should probably just completely ignore and make your own thing.

Before you delete the example mod, it might be useful to look at what is in it.  It's very basic, but it still has the important conceps that define a mod.

First off, the @Mod annotation, which marks your class as a main mod class for forge to load.
Now, there are 3 main variables you want to set in @Mod, being modid, version, and name.
the ExampleMod doesn't set name, so it defaults being your modid.
You'll also want to define all three of these as variables somewhere else, since you will need them in other places. (just as the example mod does).

It also has an @EventHandler for the init event, (you'll eventually have one for preInit, init, and postInit to do stuff).
Timing is very important with forge, so, the events are in place for a reason.

Okay so now delete the ExampleMod and it's package because those are useless and it doesn't matter.

So, now you want to create your own mod class.  If you made it this far you should already understand java naming convention, so pick a class name and a package and just poof make ur class.
Once you have that, update your group in your build.gradle to reflect this package name.

So now lets get to the @Mod annotation.

define 3 final strings in this class.  MODID, NAME, and VERSION.

	public static final String MODID = "how2mod";
	public static final String NAME = "How 2 Mod";
	public static final String VERSION = "1.0.0";
	
like so.

now create your @Mod annotation (this goes on the class).  In it, define modid, name, and version to be the three strings you just made. (Your version in here should probably reflect the one in your build.gradle)

The import is `net.minecraftforge.fml.common.Mod` if you get confused.

Your main mod class should now look similar to mine:
https://github.com/Shadows-of-Fire/How2Mod/blob/860899525689181cf2b8ac2d3de3c17da3757b65/src/main/java/shadows/how2mod/How2Mod.java

So now there are a few other things you need here.  First off, the @Instance annotation. For this, just define a blank public static variable of your mod class (public static How2Mod INSTANCE;) and throw @Instance above it.

Next up are proxies.  For proxies, you need at least two files, and if you need server-side only stuff, you need three.
There are a few ways to setup proxies, as your base proxy type can be a class or an interface, but here we'll use a class, since you won't have a special server proxy.
So create a new class named CommonProxy in a proxy subpackage.
Then, also make a ClientProxy class in the same package, that extends CommonProxy.
then, similarly to your @Instance, you need a blank CommonProxy field in your main mod class.
This field then needs to be annotated with @SidedProxy, and the two arguments need to be set as such.
clientSide = fully qualified name of your ClientProxy
serverSide = fully qualified name of your CommonProxy
See:
https://github.com/Shadows-of-Fire/How2Mod/commit/b4364ddd9f4aa846e3fa701b329d4e1f590ffb5f

Now we need some event handlers so we can actually do things with our new mod.

So now you need to create three @EventHandler methods.
(This is a special annotation used for FML lifecycle events, normal Forge events use @SubscribeEvent).

One for preInit(FMLPreInitializationEvent), one for init(FMLInitializationEvent), and one for postInit(FMLPostInitializationEvent).

These methods need to be non-static, and you need them in your main mod class.  You will also want similar methods in your proxies, but they do not need the annotation.
See:
https://github.com/Shadows-of-Fire/How2Mod/commit/b0c084dfc30863f6bffb43644e83865a0cee37a8

So now you're just about ready to make a block or an item or whatever.  But since automagic things are much better than writing out the same methods 100 times, lets setup a bit of a framework for doing things.
So make a new init package, and in there make a new class called ModRegistry.  Here is where we will define, register, and process new things that need to be registered with the game.  So lets start by making a new List<Block> and a new List<Item> (net.minecraft.item.Item and net.minecraft.block.Block)

	public static final List<Block> BLOCKS = new ArrayList<Block>();
	public static final List<Item> ITEMS = new ArrayList<Item>();
	
Now we also need two event handlers (simply put, a method with an Event as a param with @SubscribeEvent on it).
One for the Register<Block> event and one for the Register<Item> event.
In these, you want to call event.getRegistry().registerAll(List#toArray(new E[0])); for your respective lists.

	@SubscribeEvent
	public void onBlockRegister(Register<Block> event) {
		event.getRegistry().registerAll(BLOCKS.toArray(new Block[0]));
	}
	
	@SubscribeEvent
	public void onItemRegister(Register<Item> event) {
		event.getRegistry().registerAll(ITEMS.toArray(new Item[0]));
	}

Then, we need to go tell forge that this class exists and it has event handlers for forge to call.  let's do that in the CommonProxy (or the main mod class, doesn't matter, just so as long as you call it during preInit).
So, all you want to do here is call this method
MinecraftForge.EVENT_BUS.register(new ModRegistry());
in preinit, somewhere that will be called on both sides (So far, the only thing separated is your ClientProxy, which will only run code on the client).


Now i may seem like a crazy person and this may all seem pointless *but* there's just one more thing you should do.
Make a client package, and in it, create an interface named IHasModel.  This interface will only have one method (Yes, you can make it a default method, but i'll do that later, as the default impl is a bit complex.)

	@SideOnly(Side.CLIENT)
	public void registerModels();
	
That's it, thats the entire interface.  @SideOnly makes it so the method will not exist on the physical server.  And now for this interface to do work, we need to put it in one other location.  The ClientProxy.

So first off, call MinecraftForge.EVENT_BUS.register(this); in your client proxy's preinit method.

Then, create an event handler for the ModelRegistryEvent inside the client proxy.

	@SubscribeEvent
	public void onModelRegister(ModelRegistryEvent e) {
		
	}
	
Now in here, we need to loop through all our blocks and items, and if they are an IHasModel, call IHasModel#registerModels from them.

	for(Block b : ModRegistry.BLOCKS) if(b instanceof IHasModel) ((IHasModel) b).registerModels();
	for(Item i: ModRegistry.ITEMS) if(i instanceof IHasModel) ((IHasModel) i).registerModels();
	
Like so.



So now at this point you are finally ready to make a block/item.  Nice. Your workspace should resemble this repo at this commit: https://github.com/Shadows-of-Fire/How2Mod/tree/52c83bf11b620acf372bdcde06104857fd5c34df

Let's start with items, since items are about 3x easier than a Block to implement in the first place.

Make an items package, and create a class that extends Item.  Let's just call it ItemTest.

add a constructor that just takes a String, this string will be the item's registry name.

then in your constructor, you want to call 3 important methods.

	setRegistryName(name);
	setUnlocalizedName(How2Mod.MODID + "." + name);
	ModRegistry.ITEMS.add(this);

setRegistryName defines the namespace for your item, as all Items in minecraft now use this format, this step is required, or the game will crash.
setUnlocalizedName sets the unlocalized name and prefixes it with your modid for your lang file, you want to do this to avoid possible conflicts in lang keys.
The last call adds your item to your ITEMS list so it will be registered by the framework you set up earlier.

If you want your item to display in creative tab, you need to call setCreativeTab. You can use any vanilla tab, or your own, but for now let's just use CreativeTabs.MISC.

Your class should now look like this.

public class ItemTest extends Item {
	
	public ItemTest(String name) {
		setRegistryName(name);
		setUnlocalizedName(How2Mod.MODID + "." + name);
		setCreativeTab(CreativeTabs.MISC);
		ModRegistry.ITEMS.add(this);
	}

}

So now you want an item in the game, well you have your item class, and now you can make the most basic of item (that is, an item that exists, and does literally nothing).

To do this, simply define a new ItemTest in your ModRegistry after the lists.

	public static final Item TEST = new ItemTest("test");

You'll notice if you now run the game, you will see your item and it will have a missing texture.  That's because for it to have a texture, you need to implement IHasModel, and give it an item model JSON file.

So back to the ItemTest class.

Implement IHasModel, and then in registerModels(), call 

	ModelLoader.setCustomModelResourceLocation(this, 0, new ModelResourceLocation(getRegistryName(), "inventory"));
	
and now you need a JSON file, with your Item's registry name as its file name.  So off to the resources folder.

So, while we're here, lets change the mcmod.info to reflect our mod.  mcmod.info is a JSON file, so don't break the formatting.  If you're bad at JSON formatting, use a validator, such as https://jsonlint.com/
You should've changed it similarly to this: https://github.com/Shadows-of-Fire/How2Mod/commit/48d0c9c91775ed70eed5c975262ef9cc29886b52
Now back to making the Item model JSON.  Create a new folder named assets, inside that, a folder with your modid as the name (in this case, how2mod).
Then you need four other folders

	blockstates
	models
	lang
	textures
	
For now, ignore the blockstates folder.  In the lang folder, make an en_us.lang file (text document). A note about resources: case is important.  Any file with an uppercase letter will be ignored (completely just not loaded) during resource loading.
So no caps.
In the models folder, make a "block" and "item" folder.  The names are important.
In the textures folder, make a "blocks" and "items" folder.  Yeah, nice consistency mojang.

So now lets go to src\main\resources\assets\how2mod\models\item\ and make a new JSON file.  If you have no idea what a JSON is, it's basically a fancy-formatted text document with a bunch of rules.  
Since our item is named "test", we need a file named "test.json"
Now, you can use blockstates for items, but its obviously not always needed.  In this case, it wouldn't be worth it. Just copypaste this next part into your JSON.

{
  "parent": "item/generated",
  "textures": {
    "layer0": "items/sugar"
  }
}

What this does is parent the model to the vanilla model item/generated (the default item model)
and tells it to use the texture of sugar.  The name "layer0" for the texture is very important (basically all element names in json are extremely important, so don't misspell them, or you might rip your hair out wondering what's wrong).
Item models can have layers of textures, so layer0 says "put this texture on the lowest layer.

Also, you'll notice currently launching the mod doesn't register your item.  That's because you need to call super in all of your lifecycle events in your ClientProxy.
And before you actually launch the game, let's set the lang entry for your item.
in en_us.lang, define 
	item.how2mod.test.name=Test Item
The lang file works by taking key=name, where key is the lang key, and name is just about literally anything you can type there.  Lang entries are read per-line, so new entry, new line.

So now your item is ready (nice work).  Run the game using `gradlew runClient` from the command line, or by calling the runClient gradle task from within your ide (There are also launch configurations to run the game other ways.)
And your end result should basically be this: https://imgur.com/a/pjECs
Your repo should now resemble this repo at this point in time: https://github.com/Shadows-of-Fire/How2Mod/tree/7119010acf42c5f8dcca693d1561c71fe914f951

So, now you can make any basic item that doesn't do anything by creating a new ItemTest and giving it a model JSON and a lang entry.  If you want to use your own custom texture for your item, instead of "items/sugar", just define the path to your texture.

Item textures should go in textures/items, and to reference them you need to specify the domain.
The domain is your modid, vanilla textures do not requires a domain, as "minecraft" is the fallback domain.  You specify a domain as such.  Say you had a file "test.png" in textures/items.
	how2mod:items/test
that would be the string you provide to layer0 to use that texture.
So lets go make a bad looking 16x png to test this theory.

https://imgur.com/a/pvNea

See, bam, custom texture. See: https://github.com/Shadows-of-Fire/How2Mod/commit/4a0d6746954108cc2084182459e996239bd5b094

So now onto making a Block.  Make a new package called blocks and create a class extending Block (net.minecraft.block.Block) named BlockTest.
You'll notice automatically Block is not as simple as Item, as it has a required super constructor, taking a Material.  For now, just pass it Material.ROCK and ignore it.
The Material controls various things about the Block, and changing it will make it behave like you'd expect the material to.
Lets just add a constructor with a String for the name for now. We a;so want to implement IHasModel with a similar override to our item, but not exactly the same.

So this is now our block constructor.

	public BlockTest(String name) {
		super(Material.ROCK);
		setRegistryName(name);
		setUnlocalizedName(How2Mod.MODID + "." + name);
		setCreativeTab(CreativeTabs.MISC);
		ModRegistry.BLOCKS.add(this);
		ModRegistry.ITEMS.add(new ItemBlock(this).setRegistryName(getRegistryName()));
	}
	
the super sets the material.  The next four methods are the same from ItemTest. The last bit is creating an ItemBlock and adding that ItemBlock to the item list for registration.
The ItemBlock is needed for your Block to exist as an Item.  Blocks are strictly placed in the world.  Without an ItemBlock, it cannot be dropped, or held, or anything of the sort.

So now our constructor is explained, and lets implement IHasModel.
Oh yeah, and we're here right now: https://github.com/Shadows-of-Fire/How2Mod/commit/bfca6079737f91a7320adb5509024b143e2fd780
You should really be following these commits.

	@Override
	public void registerModels() {
		ModelLoader.setCustomModelResourceLocation(Item.getItemFromBlock(this), 0, new ModelResourceLocation(getRegistryName(), "inventory"));
	}
	
So sCMRL takes an item, but this is a block, so we need to use Item.getItemFromBlock to get this block's ItemBlock (the one we made in the constructor) to use it for the model location.
See, Models are special as they only exist for Items, blocks in-world are handled by Blockstates, which are mapped automatically based on the block's registry name (you can change this, but its not required).

So now we have that, let's define a new BlockTest.

	public static final Block TEST_BLOCK = new BlockTest("test_block");
	
Now that just sits it there and it gets put on all the nice lists for registration and everything.
Nice system as long as you remember to put the things on their lists.

So, now the thing needs a texture. For that, you need a blockstate. Which is another json file, which uses the registry name of the block, and goes in the blockstates folder.

This file is src\main\resources\assets\how2mod\blockstates\test_block.json

{
	"forge_marker": 1,
	"defaults": {
		"model": "cube_all",
		"textures": {
			"all": "blocks/stone"
		}
	},
	"variants": {
		"normal": [{}],
		"inventory": [{}]
	}
}

The forge_marker says this is a forge blockstate.
the defaults category is applied to all possible states of this block, in this case, only the normal state (variant) as it has no properties.
the model and textures are how the block is actually rendered.  In this case, "cube_all" is the default 6-side 1-texture block, and it's texture param is "all". The texture name is based on the model you're using, so keep that in mind.
The variants are where you define your blockstates, in this case, we only have the default (normal) and the inventory variant, which is the same as the normal.
The reason the inventory variant is used is that some blocks might need a different inventory model, and that allows for it.
But since we don't, we could use "normal" in the sCMRL of our BlockTest class instead of "inventory".
Either way, now starting up the game will have you a nice test block, but we should get a lang entry.

https://imgur.com/a/H2NEs

So now we have this.
Similarly to texturing our item, to use a custom block texture, you simply set it in the "textures" part of the blockstate.
In this case, we change "all" to "how2mod:blocks/test" instead of "blocks/stone".

So, now you have the ability to create an infinite number of basic blocks and items. But you probably want something more, maybe blocks/items that *do* something.

So before we get into *doing* things, lets understand metadata.  There are only so many ID's in minecraft, 4k blocks, and 32k items.  And with modpacks being as large as they are, spamming a bunch of block ids is bad (its not so bad for items, there's *so* many item ids)

So, using metadata for items is much easier than using it for blocks.  For items, all you need to do is this, lets begin by making a new Item class.  We'll be calling this class ItemMetaTest and it will extend ItemTest.
The first thing we need to do is call
	setHasSubtypes(true);
in the constructor.  This tells our item that is has subtypes (metadata) and it is free to use them.  Then we need to override getMetadata in order to now use this enabled metadata.

	@Override
	public int getMetadata(int damage) {
		return damage;
	}

Now, defaultly, this returns 0, so a normal item has no metadata. 

Side note, added later: If you want to clamp this, you can change it to something like 

	return damage > max ? damage : max;
	
Otherwise your item can have a max metadata of up to 32768
	
In essence, for items to function, there are a bunch of methods you need to override and then tell said item to do things in them.  There are a lot of them, and perhaps later i will create a base class with most of these methods and a set of comments showing what it is they do.
For now, you have an item with metadata.  You don't have to do anything else, but unless you override a few other functions, they will all have the same name, and only meta 0 will have a texture.
So first off, let's override getSubItems.  This allows our item to place as many ItemStack's on its own creative tab as it wants.

	@Override
    public void getSubItems(CreativeTabs tab, NonNullList<ItemStack> list) {
        if (this.isInCreativeTab(tab)) for(int i = 0; i < 16; i++) list.add(new ItemStack(this, 1, i));
    }

The method call isInCreativeTab is REQUIRED, forgetting it means your item will show up on *every* creative tab ever.
Now, this adds 16 copies of your item to the creative tab, each with a different metadata.
Now we need to override registerModels() from IHasModel, as the current impl from ItemBase only registers a model location for meta 0.

	@Override
	public void registerModels() {
		for(int i = 0; i < 16; i++) ModelLoader.setCustomModelResourceLocation(this, i, new ModelResourceLocation(getRegistryName(), "meta=" + i));
	}
	
So doing this makes the item look in a blockstate with the item's registry name and a variant named meta, with value equivalent to the current stack's metadata.
Now you may be thinking blockstates are just for blocks, but that's already not true, as your BlockTest uses a blockstate for it's item model.
So, let's go make a normal item blockstate.

This is now our item blockstate.
https://github.com/Shadows-of-Fire/How2Mod/blob/458ab28c8e21dfb4333bd6e65e42a2f60f7feba6/src/main/resources/assets/how2mod/blockstates/test_meta_item.json

Notice we are using builtin/generated and the transform forge:default-item instead of item/generated, that is because in a blockstate, you cannot use models that are in the item folder.  Only builtin/generated or block models.
So, right now, all these items use the same texture.  They can use textures from the items folder, the limit is strictly on model.
So lets go make another trash texture, define a new ItemMetaTest, and launch the game.  You may also want to get yourself a lang entry.  Right now, all 16 variants use the same name.

You should end up with something like this: https://imgur.com/a/1M6lA

Now, lets go and replace all of these so they have different textures and different names.
To change the textures, simply edit the "textures" section of the blockstate per variant.
To change the names, we'll need another method override.

	@Override
	public String getUnlocalizedName(ItemStack stack) {
		return super.getUnlocalizedName() + "." + stack.getMetadata();
	}
	
Simply using this in the Item class changes item.how2mod.test_meta_item.name into a set of item.how2mod.test_meta_item.X.name, where X is the current metadata.
So, now go edit your lang file and textures, and you should end up with something like this: https://imgur.com/a/QGBAE
Now that we have this, we can work on making the item do something.  And, making it do different things based on metadata.  So lets move on to functional Items.
We are now at this commit: https://github.com/Shadows-of-Fire/How2Mod/commit/28c86d7fe9d735ae332acab68548d1437b4cbfa5

We will start by making our ItemTest do something on right click, and another thing on right clicking a block.  There are two methods to handle this.

To start off, the method that handles item right click is 

    public ActionResult<ItemStack> onItemRightClick(World worldIn, EntityPlayer playerIn, EnumHand handIn)
    {
        return new ActionResult<ItemStack>(EnumActionResult.PASS, playerIn.getHeldItem(handIn));
    }

let's override that to send the player a chat message when a block is clicked.

	@Override
    public ActionResult<ItemStack> onItemRightClick(World world, EntityPlayer player, EnumHand hand) {
        if(world.isRemote)
        	player.sendMessage(new TextComponentString("You have right clicked with a " + this.getRegistryName()));
        return new ActionResult<ItemStack>(EnumActionResult.SUCCESS, player.getHeldItem(hand));
    }
	
The important check here is if(world.isRemote).  isRemote is possibly one of the most important checks, as this decides if the current world is a logical client (a remote) or a logical server (non-remote). 
Strictly logical client/server, as the physical client runs an integrated server, so both sides still exist.
Without this check, the player would recieve two messages.  We only want to send this message to this client, so we run this on the client world.
So go load up the game an test this. Your meta item will also be able to send the same message, but it will not know its current meta, so all variants do the same thing.
You should end up with something like this: http://imgur.com/ukuqW2t

Now let's make it do something different on a block.  Block clicks are handled by a different method, but if that method is not overriden, it falls back to onItemRightClick.  The method in question is

    public EnumActionResult onItemUse(EntityPlayer player, World worldIn, BlockPos pos, EnumHand hand, EnumFacing facing, float hitX, float hitY, float hitZ)
    {
        return EnumActionResult.PASS;
    }

So let's make that do something.

	@Override
    public EnumActionResult onItemUse(EntityPlayer player, World world, BlockPos pos, EnumHand hand, EnumFacing facing, float hitX, float hitY, float hitZ) {
        if(world.isRemote)
        	player.sendMessage(new TextComponentString("You have right clicked a " + world.getBlockState(pos).getBlock().getRegistryName() + " with a " + this.getRegistryName()));
        return EnumActionResult.SUCCESS;
    }
	
This will now send a message with the name of the block that you clicked, and the item you are holding.  Lets detail all the arguments here to understand.
EntityPlayer player: this is whoever is using this item.  Currently, you.
World world: This is the current world, remember, this is run twice, so it's run on a server world, and the client world. We only send our message on the client.
BlockPos pos: The position (BlockPos is a wrapper for an (x, y, z) coordinate) of the block you clicked
EnumHand hand: The hand you are holding the item with.
EnumFacing facing: The face of the block you clicked on.
float hitX: from 0 to 1, the x coordinate of where on the block you clicked. so the bottom left corner would be (0,0), and the top right is (1,1)
float hitY: same concept, but a y coordinate.
float hitZ: also same concept, but a z coordinate.

So, to get the block we clicked on, we use world.getBlockState(pos), which returns an IBlockState at the current position.  An IBlockState is a block in the world, as block can have different properties, a IBlockState is created for each combination.
IBlockStates can return their block through .getBlock(), and then we can get the name via getRegistryName().
IBlockState will be covered later.

Now, both the item and the meta item will now function as such: http://imgur.com/yLC4Dpj
(but what if we want to handle item metadata?)'
Well, now, let's override these functions in our meta item.

	@Override
	public ActionResult<ItemStack> onItemRightClick(World world, EntityPlayer player, EnumHand hand) {
		ItemStack stack = player.getHeldItem(hand);
		if (world.isRemote)
			player.sendMessage(new TextComponentString("You have right clicked with a " + I18n.format(getUnlocalizedName(stack) + ".name")));
		return new ActionResult<ItemStack>(EnumActionResult.SUCCESS, stack);
	}

	@Override
	public EnumActionResult onItemUse(EntityPlayer player, World world, BlockPos pos, EnumHand hand, EnumFacing facing, float hitX, float hitY, float hitZ) {
		ItemStack stack = player.getHeldItem(hand);
		if (world.isRemote)
			player.sendMessage(new TextComponentString("You have right clicked a " + world.getBlockState(pos).getBlock().getRegistryName() + " with a " + I18n.format(getUnlocalizedName(stack) + ".name")));
		return EnumActionResult.SUCCESS;
	}
	
Using these two functions, we get the current ItemStack (as Item is a singleton, so there is only ever one Item, but there are many ItemStack's.  This is how metadata works.  Similar concept for Blocks and IBlockState's)
through player.getHeldItem(hand), as we are passed the hand and the player, we can get this ItemStack (which should have our item, unless someone is setting something on fire).
now, before, we were just using the item's registry name.  And, while we could continue to do that, and also use the stack metadata, lets just use the stack name.
I18n.format is a client-only method that attempts to translate a given lang key.  If it fails, it returns the lang key.  Now, there are two I18n's, one is deprecated.  Don't touch it.
The non-deprecated one is the one from net.minecraft.client.resources, and it is a client-only class.  Meaning, attempting to use it on a dedicated server will crash the server.
However, since our call is inside a if(world.isRemote), we only run on the client world, where I18n exists.

Now we end up with something like this: https://imgur.com/a/M13sk

So, essentially, to do things on item clicks, those are the methods to use.
To base things on the ItemStack instead of the Item directly, you have to get the stack using player.getHeldItem(hand).
Then you can base things off the stacksize (stack.getCount()) or the metadata (stack.getMetadata())

So now we're at this commit: https://github.com/Shadows-of-Fire/How2Mod/commit/50bb9d5cd670e883bccdba140dec05ddedd98469
and I'll come back to write about blockstates in the morning or something.  Cuz its 5 am, and I still don't know why I'm doing this in the first place -.<

It is now 7 pm and i apparently have motivation to do anything again. I'm real gud.
so now there are a few important conceps about blockstates.
Every Block exists in the world as an IBlockState, (both of these are singletons, but a single Block can have multiple IBlockStates)
All possible IBlockStates are created during the super call to block, based on the IProperties assigned to the block state container in createBlockState()
So, real definitions.
Block: The block, the single instance of the block.  There is only ever one of these per registry name, and it exists strictly in-world (but even then, not really).
IBlockState: A manifestation of a block in the world, based on what properties are assigned to the block.
IProperty: A value that can be part of an IBlockState, and can be obtained from an IBlockState as long as that property exists.  Trying to get a property a state doesn't have will crash.

So, for items, there is only metadata.  Blockstates have to be serialized to meta to be saved, and converted back.  This is handled per-block, by you.
There are two methods that need to be overriden, or no states will persist through saving the game.
	
	public IBlockState getStateFromMeta(int meta)
	public int getMetaFromState(IBlockState state)
	
And with that in mind, let's go make a new block class.  We will be extending our old block to do this.

public class BlockWithStates extends BlockTest{

	public BlockWithStates(String name) {
		super(name);
	}

}

Literally this is all we end up with.  So lets begin by applying states.  For the most basic property, we will be creating a PropertyInteger.
To do this, define a public static final PropertyInteger ranging from 0 to 7.

	public static final PropertyInteger META = PropertyInteger.create("meta", 0, 7);

So, now we want to override three methods, based on how our property works.

	@Override
	public int getMetaFromState(IBlockState state) {
		return state.getValue(META);
	}
	
	@Override
	public IBlockState getStateFromMeta(int meta) {
		return this.getDefaultState().withProperty(META, meta);
	}
	
	@Override
	public BlockStateContainer createBlockState() {
		return new BlockStateContainer(this, META);
	}
	
The first controls how our IBlockStates will be saved to disk.  This integer must be from 0 to 15, inclusive, and cannot be anything else.
The second controls how the world knows how to deserialize our IBlockState from its meta.
These both have to be handled manually, and depending on how many properties you have, it can get a little complex.  Right now, we just have a property integer, and only one property, so it's similar to how item meta works.
The last method tells minecraft about the property we want our block to have, in this case, the META property we just created.
Now, there are a few other things that need to happen to use states here.  So, let's add another line to our constructor.

	setDefaultState(this.blockState.getBaseState().withProperty(META, 0));
	
This tells minecraft what to return in getDefaultState(), which is generally what we is used to get the default IBlockState of any block.  It's also generally used as a fallback should something fail.
Your new block class should now look like this: https://github.com/Shadows-of-Fire/How2Mod/blob/07f20379cadf37c167c52e980fc902e776c4779b/src/main/java/shadows/how2mod/blocks/BlockWithStates.java
However, we aren't ready to go in game and see this block yet.  As currently, it won't have a name, or a texture, or anything of the sort.
We need a few other things: A custom ItemBlock, lang entries, and our blockstate JSON.

So, now let's revisit our BlockTest constructor so that we can not register the default ItemBlock.
Change our constructors to match these:

	public BlockTest(String name, boolean hasCustomItemBlock) {
		super(Material.ROCK);
		setRegistryName(name);
		setUnlocalizedName(How2Mod.MODID + "." + name);
		setCreativeTab(CreativeTabs.MISC);
		ModRegistry.BLOCKS.add(this);
		if(!hasCustomItemBlock) ModRegistry.ITEMS.add(new ItemBlock(this).setRegistryName(getRegistryName()));
	}
	
	public BlockTest(String name) {
		this(name, false);
	}
	
We're going to add the other constructor to maintain compat with our declared BlockTest, and we want to switch our BlockWithStates to use super(name, true) instead of super(name).
So, now, let's go create our ItemBlock class.  Once we make it, our constructor needs to do a few things.  Super with a BlockWithStates, set the registry name to our block's registry name, and setHasSubtypes.
We won't add a ITEMS.add(this) call because we will be doing that in our block.  The other thing we need to do is override getMetadata, so we can have metadata.
You should end up with this

	public class ItemBlockTest extends ItemBlock {

		public ItemBlockTest(BlockWithStates block) {
			super(block);
			setRegistryName(block.getRegistryName());
			setHasSubtypes(true);
		}
	
		@Override
		public int getMetadata(int damage) {
			return damage;
		}

	}

now let's go back to our Block and make this itemblock in our constructor.

	ModRegistry.ITEMS.add(new ItemBlockTest(this));

That's basically all we need.  Now, we need to override getSubBlocks in our Block, so we can populate the creative tab with 1 item for each of our states.
Unlike our item, we only made 8 blockstates, instead of 16 item variants.  We could have 16 variants by extending the PropertyInteger to be from 0 to 15 instead of 0 to 7, but same concept, so no reason to.

	@Override
	public void getSubBlocks(CreativeTabs tab, NonNullList<ItemStack> list) {
		for(int i = 0; i < 8; i++) list.add(new ItemStack(this, 1, i));
	}
	
Just like that.  Note we do not have to check if(isInCreativeTab(this)) since this is a block, and the ItemBlock checks this already and runs getSubBlocks by default.

Now we need our blockstate, and to override registerModels().  Since it'll be easier to do the override, lets do that first.

	@Override
	public void registerModels() {
		for(int i = 0; i < 8; i++) ModelLoader.setCustomModelResourceLocation(Item.getItemFromBlock(this), i, new ModelResourceLocation(getRegistryName(), "meta=" + i));
	}

This will register our itemblock's for meta 0-7 to the same blockstate variant, so the inventory and the block in-world will be the same.
Now we just need the blockstate JSON.  We can essentially use our item blockstate as a base, since using only a single property integer makes them nearly equivalent.
So now we get this: https://github.com/Shadows-of-Fire/How2Mod/blob/7056f658c3ab55ebf935763211148e74ad1966ab/src/main/resources/assets/how2mod/blockstates/test_state_block.json
Honestly, the only thing that matters is the cube_all, and the fact that the textures are named "all" as their selector.  The file name and texture paths can be different.  Hell, if you're feeling confident, you could even make a custom model using an editor.
There are also other vanilla models that things can be based off of.
This blockstate file applies the "cube_all" model to all states, but then applies a different texture based on the state.  Now, I'll go create some placeholder textures, so they actually appear.
You can either do that as well, or just steal them from the repo: https://github.com/Shadows-of-Fire/How2Mod/tree/master/src/main/resources/assets/how2mod/textures/blocks (testblock0-7)

So, now, plug in some lang entries (you honestly don't have to for testing), define your block, and then there you have it.
EXCEPT!
There is *one* more bit of the puzzle you need for your itemblocks to actually place a different block based on the itemstack, and that is getStateForPlacement.

	@Override
    public IBlockState getStateForPlacement(World world, BlockPos pos, EnumFacing facing, float hitX, float hitY, float hitZ, int meta, EntityLivingBase placer, EnumHand hand) {
        return getDefaultState().withProperty(META, meta);
    }
	
We want this in our block class.  This tells our itemblock to place a different IBlockState based on the meta of the ItemStack being used.

You will also notice that currently, all of your itemblocks share the same name.  To solve this, simply use the same getUnlocalizedName override that was used in ItemMetaTest:

	@Override
	public String getUnlocalizedName(ItemStack stack) {
		return super.getUnlocalizedName() + "." + stack.getMetadata();
	}
	
Then you can go enter in your lang entries, and well, do stuff.

After defining your block, you should end up with something like this: http://imgur.com/sR2CPkJ
However, there are *even more* issues apparent with making it work correctly.  As it stands, all of thse blocks will only drop the 0 block.
Now, there are a lot of methods that control how drops are processed, but since we only need to change the metadata of the dropped item, we can just change

    public int damageDropped(IBlockState state)
    {
        return 0;
    }
	
to reflect our blockstate

	@Override
    public int damageDropped(IBlockState state) {
        return state.getValue(META);
    }

Now you should be able to break your block with a pickace and simply collect the correct item, as such: http://imgur.com/4iE2GOp
So, issue is now, the misc tab is becoming pretty cluttered with our stuff: http://imgur.com/yxKvcwx So, we probably want our own.  Then, we can go tune our blocks to not all be Material.ROCK and break instantly.
We could also make them do something.  Who knows. (me, probably, since i'm writing this) (i don't know right now tho)

So since none of our items look amazing lets make a new item that we will use specifically for our creative tab display.
Since making a creative tab is the easiest thing ever, we will only cover this briefly.  Also, we are here right now: https://github.com/Shadows-of-Fire/How2Mod/commit/2574af792a5bfc31d90d7180cb05bb5435bd501c

Now, we could define an entire other item for our creative tab, or we could just expand on our test meta item, and use the 16th metadata (Items do not have a hard limit of 15 like blocks do).
So lets do that.  Expand the loop in registerModels() in ItemMetaTest to be i < 17 instead of i < 16, and set a texture for the meta of 16 in the test_meta_item blockstate JSON.
Note, we will not be expanding getSubItems, as this will be strictly for display on the creative tab.  You can still obtain the item via /give though.
Sometimes it makes sense to make a new item to display on the creative tab, (BiomesOPlenty does this with their Earth item), but right now we can use subtypes.  This new item should be unobtainable, so it doesn't *really* need a lang entry.
You can add one if you want.

So, now, verifying you did everything like this commit: https://github.com/Shadows-of-Fire/How2Mod/commit/1b048dd65316b61da021a2f607dce39eb7904ad8
We can make our creative tab.  We will be using an anonymous implementation of the abstract CreativeTabs class.

	public static final CreativeTabs TAB = new CreativeTabs(How2Mod.MODID) {

		@Override
		public ItemStack getTabIconItem() {
			return new ItemStack(META_TEST, 1, 16);
		}
		
	};
	
Define this in your ModRegistry under the Lists, but before you declare any blocks or items.
And bam, that's a creative tab.  Now, lets go put all our things on this tab instead of Misc.
To change that, just change setCreativeTab to point to this new tab.
So, unless you did this https://github.com/Shadows-of-Fire/How2Mod/commit/a602f8272a2be2dce7ca9df788606ed5d70bdccc on accident, you now end up with this: http://imgur.com/4iDnnyA
You may notice the itemGroup.how2mod, that's a lang key.  This tab currently has no lang key, so lets go fix that.
	
	itemGroup.how2mod=How 2 Mod Test Things
	
So now our tab is named, our items are there, and we are at this commit: https://github.com/Shadows-of-Fire/How2Mod/commit/28e41c5d3a75b41a2124b2df1e3d415bda9a05b0

And on that note, its 3 am, so no more anything tonight.  Poor u.  U can learn later.
Its not 3 am anymore so maybe more things.  Lets make our BlockWithStates be more than a useless thing that sounds like a rock and breaks instantly.
So, let's change the hardness and resistance of our block so it doesn't break instantly, and so it doesnt get completely blown away by tnt.  It's a rock after all.	

	setHardness(2.0F);
	setResistance(2.0F);

We can add these lines to our constructor so our block now has a hardness and a resistance.  Important thing to remember though, is that to have a custom resistance, you have to set it *after* the hardness.
This is because for whatever reason, setHardness runs this code

    if (this.blockResistance < hardness * 5.0F)
    {
        this.blockResistance = hardness * 5.0F;
    }

No clue why it does that, honestly.  But, either way, now your block will no longer instant-break, and you won't accidentally delete it by punching it (since it wouldn't drop without a pickaxe either way).

So now lets go make this block do something. There are a couple methods to override to make Blocks do things.

	public void onBlockClicked(World worldIn, BlockPos pos, EntityPlayer playerIn) | Called when the block is left clicked.
	public boolean onBlockActivated(World worldIn, BlockPos pos, IBlockState state, EntityPlayer playerIn, EnumHand hand, EnumFacing facing, float hitX, float hitY, float hitZ) | Called when the block is right clicked.
	public void onBlockDestroyedByExplosion(World worldIn, BlockPos pos, Explosion explosionIn) | Guess, honestly.
	public void updateTick(World worldIn, BlockPos pos, IBlockState state, Random rand) | This is called by randomTick if the block is setTickRandomly(true).  It will also be called on a scheduled block update, or by some mods.
	public void randomDisplayTick(IBlockState stateIn, World worldIn, BlockPos pos, Random rand) | Lets you do things like spawn particles. This method is SideOnly(Side.CLIENT)
	public void onBlockDestroyedByPlayer(World worldIn, BlockPos pos, IBlockState state) | Also guess, like, method names are sometimes useful.
	public void neighborChanged(IBlockState state, World worldIn, BlockPos pos, Block blockIn, BlockPos fromPos) | Called when nearby blocks change.  This method is @Deprecated, but that's really completely pointless in minecraft.
	
Side note about deprecation:  The general concept of @Deprecated in minecraft code (Not forge code, stay away from deprecated forge code or lex will hide in ur house) is that it means you shouldn't call it.  You will still need to override it to do stuff.

	public void onBlockAdded(World worldIn, BlockPos pos, IBlockState state) | Called after the block is set in the Chunk data, but before the Tile Entity is set
	public void breakBlock(World worldIn, BlockPos pos, IBlockState state) | Called after the block is destroyed, before TileEntities are removed, by default, just tries to remove a tile entity from this pos.
	public int quantityDropped(IBlockState state, int fortune, Random random) | How many of getItemDropped(state, rand, fortune) we drop when this block is broken.
	public Item getItemDropped(IBlockState state, Random rand, int fortune) | The item to drop on break by default.
	public int damageDropped(IBlockState state) | The metadata of a getItemDropped(state, rand, fortune) to drop.
	public void onEntityWalk(World worldIn, BlockPos pos, Entity entityIn) | When an entity walks (strictly on the top face) of this block.
	public void onEntityCollidedWithBlock(World worldIn, BlockPos pos, IBlockState state, Entity entityIn) | Called when an entity is inside this block's space.
	public void onBlockPlacedBy(World worldIn, BlockPos pos, IBlockState state, EntityLivingBase placer, ItemStack stack) | Called right after someone uses this block's ItemBlock.
	public void onFallenUpon(World worldIn, BlockPos pos, Entity entityIn, float fallDistance) | When something falls on this block.
	public void onLanded(World worldIn, Entity entityIn) | Similar to the last one, but not completely. Same concept tho.
	public void onBlockHarvested(World worldIn, BlockPos pos, IBlockState state, EntityPlayer player) | Called before the block is set to air, even if the player doesnt have the correct tool to harvest.
	public void fillWithRain(World worldIn, BlockPos pos) | Called randomly during rain.
	public void addInformation(ItemStack stack, @Nullable World player, List<String> tooltip, ITooltipFlag advanced) | Adds tooltips to this block's ItemBlock
	public boolean isFireSource(World world, BlockPos pos, EnumFacing side) | Returning true to this makes this block an infinite fire source, like netherrack
	public void getDrops(NonNullList<ItemStack> drops, IBlockAccess world, BlockPos pos, IBlockState state, int fortune) | Overriding this lets you change what things your block drops.
	By default, it uses getItemDropped, quantityDropped, and damageDropped to create the drops. 


So I really stalled work on this, but I did make one minor change.  No telling if I'll actually go back and continue it.
Anyway, this new commit is about side safety and localization.  This changes the use of the SideOnly class I18n and the sending of a TextComponentString into a TextComponentTranslation
This will make these messages support other languages and not crash if these methods are called on the server. It also sends the messages from the server world (world.isRemote) -> (!world.isRemote).  See the commit "Localization is a thing"















