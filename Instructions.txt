How 2 minecraft mod the text document:

First go get urself a nice forge mdk from http://files.minecraftforge.net/
then extract it into a folder somewhere

Then delete everything deleted in this commit right here:
https://github.com/Shadows-of-Fire/How2Mod/commit/d55fbaa0f6d84c91f5114053fa302e4da9bcb0f7

Now you need to go actually get the gradle wrapper again, since you just deleted 2.14 (the very old version forge ships)
https://gradle.org/releases/ Go get yourself the binary-only edition of the latest gradle.
Since this is the actual version of gradle, you'll need to do a few things to use it.

You have two options here: Either install gradle to your system, or temporarily extract and generate the wrapper files.

Since the second option is less compilated, let's go with that.

So extract the gradle zip into some folder, then run the command "gradle w" from a command prompt or command line.
then run "gradle --stop" to close the daemon so you can delete this folder later.
Now you have generated 4 files you need to go put the wrapper back in your forge workspace.

gradlew
gradlew.bat
gradle (folder)

Move those three things into the dir with your mdk and then we can get back to that. (you can then delete the old gradle folder). See commit: https://github.com/Shadows-of-Fire/How2Mod/commit/e4ba4e1b92751816d7267780b8f84b759cc2757b

Then if you want a bit of understanding about the build.gradle, I've changed the default comments on them because they are useless. https://github.com/Shadows-of-Fire/How2Mod/blob/8b52990a88a6318e68a43d540754ff70ce5218a9/build.gradle

Now, there are a few things you need for this (one of them is a JDK, the other is an IDE).
If you dont have a JDK, you need to install it and properly configure it.
http://www.oracle.com/technetwork/java/javase/downloads/index.html
(I won't be going over that)
If you don't have an IDE, you need to go get one.  The only "supported" ones are IntelliJ IDEA and Eclipse.
I use eclipse, but this is a preference thing, so it really doesn't matter.
https://www.jetbrains.com/idea/download/ <- IntelliJ IDEA
https://www.eclipse.org/downloads/ <- Eclipse (giant Download 64 Bit button)

So now you have all those things you can actually start making a mod woo nice job
Back to the forge folder and run the command "gradlew sDecW eclipse" (for eclipse) or "gradlew sDecW idea" (for IDEA).
sDecW means setupDecompWorkspace (it's literally just the shorter command version, either works) and the second command makes certain IDE files.
sDecW will take a while, so just sit there and let it do stuff.  If it fails, it probably means your JDK is improperly configured.  The whole process is that this command downloads forge, the mappings, and minecraft.  It then decompiles minecraft, deobfuscates it (remaps most of the method and field names into readable ones), and then recompiles it so it can run in a dev environment, and creates a linked source jar for you to work with.  It's basically all magic.

Now here's the part where its important that I use eclipse, because if you're using IDEA, you'll have to figure out the idea equivalent of certain things I do.  *anyway* lets begin.

Now that your sDecW is finished (you should see a BUILD SUCCESSFUL) in the command window, you need to import the project into your IDE.  I think i'm gonna start using newlines here to split Eclipse and IDEA, in case anyone wants to write in here how that works.

ECLIPSE:  Use the import function and import an Existing Gradle Project.  Then just direct it to the folder containing your build.gradle and hit finish. Then you should end up with this: https://imgur.com/KLCwWmu

IDEA: ?

So now we basically just have the example mod in here. (com.example.examplemod.ExampleMod)
Which you can work with easily, but you should probably just completely ignore and make your own thing.

Before you delete the example mod, it might be useful to look at what is in it.  It's very basic, but it still has the important conceps that define a mod.

First off, the @Mod annotation, which marks your class as a main mod class for forge to load.
Now, there are 3 main variables you want to set in @Mod, being modid, version, and name.
the ExampleMod doesn't set name, so it defaults being your modid.
You'll also want to define all three of these as variables somewhere else, since you will need them in other places. (just as the example mod does).

It also has an @EventHandler for the init event, (you'll eventually have one for preInit, init, and postInit to do stuff).
Timing is very important with forge, so, the events are in place for a reason.

Okay so now delete the ExampleMod and it's package because those are useless and it doesn't matter.

So, now you want to create your own mod class.  If you made it this far you should already understand java naming convention, so pick a class name and a package and just poof make ur class.
Once you have that, update your group in your build.gradle to reflect this package name.

So now lets get to the @Mod annotation.

define 3 final strings in this class.  MODID, NAME, and VERSION.

	public static final String MODID = "how2mod";
	public static final String NAME = "How 2 Mod";
	public static final String VERSION = "1.0.0";
	
like so.

now create your @Mod annotation (this goes on the class).  In it, define modid, name, and version to be the three strings you just made. (Your version in here should probably reflect the one in your build.gradle)

The import is `net.minecraftforge.fml.common.Mod` if you get confused.

Your main mod class should now look similar to mine:
https://github.com/Shadows-of-Fire/How2Mod/blob/860899525689181cf2b8ac2d3de3c17da3757b65/src/main/java/shadows/how2mod/How2Mod.java

So now there are a few other things you need here.  First off, the @Instance annotation. For this, just define a blank public static variable of your mod class (public static How2Mod INSTANCE;) and throw @Instance above it.

Next up are proxies.  For proxies, you need at least two files, and if you need server-side only stuff, you need three.
There are a few ways to setup proxies, as your base proxy type can be a class or an interface, but here we'll use a class, since you won't have a special server proxy.
So create a new class named CommonProxy in a proxy subpackage.
Then, also make a ClientProxy class in the same package, that extends CommonProxy.
then, similarly to your @Instance, you need a blank CommonProxy field in your main mod class.
This field then needs to be annotated with @SidedProxy, and the two arguments need to be set as such.
clientSide = fully qualified name of your ClientProxy
serverSide = fully qualified name of your CommonProxy
See:
https://github.com/Shadows-of-Fire/How2Mod/commit/b4364ddd9f4aa846e3fa701b329d4e1f590ffb5f

Now we need some event handlers so we can actually do things with our new mod.

So now you need to create three @EventHandler methods.
(This is a special annotation used for FML lifecycle events, normal Forge events use @SubscribeEvent).

One for preInit(FMLPreInitializationEvent), one for init(FMLInitializationEvent), and one for postInit(FMLPostInitializationEvent).

These methods need to be non-static, and you need them in your main mod class.  You will also want similar methods in your proxies, but they do not need the annotation.
See:
https://github.com/Shadows-of-Fire/How2Mod/commit/b0c084dfc30863f6bffb43644e83865a0cee37a8

So now you're just about ready to make a block or an item or whatever.  But since automagic things are much better than writing out the same methods 100 times, lets setup a bit of a framework for doing things.
So make a new init package, and in there make a new class called ModRegistry.  Here is where we will define, register, and process new things that need to be registered with the game.  So lets start by making a new List<Block> and a new List<Item> (net.minecraft.item.Item and net.minecraft.block.Block)

	public static final List<Block> BLOCKS = new ArrayList<Block>();
	public static final List<Item> ITEMS = new ArrayList<Item>();
	
Now we also need two event handlers (simply put, a method with an Event as a param with @SubscribeEvent on it).
One for the Register<Block> event and one for the Register<Item> event.
In these, you want to call event.getRegistry().registerAll(List#toArray(new E[0])); for your respective lists.

	@SubscribeEvent
	public void onBlockRegister(Register<Block> event) {
		event.getRegistry().registerAll(BLOCKS.toArray(new Block[0]));
	}
	
	@SubscribeEvent
	public void onItemRegister(Register<Item> event) {
		event.getRegistry().registerAll(ITEMS.toArray(new Item[0]));
	}

Then, we need to go tell forge that this class exists and it has event handlers for forge to call.  let's do that in the CommonProxy (or the main mod class, doesn't matter, just so as long as you call it during preInit).
So, all you want to do here is call this method
MinecraftForge.EVENT_BUS.register(new ModRegistry());
in preinit, somewhere that will be called on both sides (So far, the only thing separated is your ClientProxy, which will only run code on the client).


Now i may seem like a crazy person and this may all seem pointless *but* there's just one more thing you should do.
Make a client package, and in it, create an interface named IHasModel.  This interface will only have one method (Yes, you can make it a default method, but i'll do that later, as the default impl is a bit complex.)

	@SideOnly(Side.CLIENT)
	public void registerModels();
	
That's it, thats the entire interface.  @SideOnly makes it so the method will not exist on the physical server.  And now for this interface to do work, we need to put it in one other location.  The ClientProxy.

So first off, call MinecraftForge.EVENT_BUS.register(this); in your client proxy's preinit method.

Then, create an event handler for the ModelRegistryEvent inside the client proxy.

	@SubscribeEvent
	public void onModelRegister(ModelRegistryEvent e) {
		
	}
	
Now in here, we need to loop through all our blocks and items, and if they are an IHasModel, call IHasModel#registerModels from them.

	for(Block b : ModRegistry.BLOCKS) if(b instanceof IHasModel) ((IHasModel) b).registerModels();
	for(Item i: ModRegistry.ITEMS) if(i instanceof IHasModel) ((IHasModel) i).registerModels();
	
Like so.



So now at this point you are finally ready to make a block/item.  Nice. Your workspace should resemble this repo at this commit: https://github.com/Shadows-of-Fire/How2Mod/tree/52c83bf11b620acf372bdcde06104857fd5c34df

Let's start with items, since items are about 3x easier than a Block to implement in the first place.

Make an items package, and create a class that extends Item.  Let's just call it ItemTest.

add a constructor that just takes a String, this string will be the item's registry name.

then in your constructor, you want to call 3 important methods.

	setRegistryName(name);
	setUnlocalizedName(How2Mod.MODID + "." + name);
	ModRegistry.ITEMS.add(this);

setRegistryName defines the namespace for your item, as all Items in minecraft now use this format, this step is required, or the game will crash.
setUnlocalizedName sets the unlocalized name and prefixes it with your modid for your lang file, you want to do this to avoid possible conflicts in lang keys.
The last call adds your item to your ITEMS list so it will be registered by the framework you set up earlier.

If you want your item to display in creative tab, you need to call setCreativeTab. You can use any vanilla tab, or your own, but for now let's just use CreativeTabs.MISC.

Your class should now look like this.

public class ItemTest extends Item {
	
	public ItemTest(String name) {
		setRegistryName(name);
		setUnlocalizedName(How2Mod.MODID + "." + name);
		setCreativeTab(CreativeTabs.MISC);
		ModRegistry.ITEMS.add(this);
	}

}

So now you want an item in the game, well you have your item class, and now you can make the most basic of item (that is, an item that exists, and does literally nothing).

To do this, simply define a new ItemTest in your ModRegistry after the lists.

	public static final Item TEST = new ItemTest("test");

You'll notice if you now run the game, you will see your item and it will have a missing texture.  That's because for it to have a texture, you need to implement IHasModel, and give it an item model JSON file.

So back to the ItemTest class.

Implement IHasModel, and then in registerModels(), call 

	ModelLoader.setCustomModelResourceLocation(this, 0, new ModelResourceLocation(getRegistryName(), "inventory"));
	
and now you need a JSON file, with your Item's registry name as its file name.  So off to the resources folder.

So, while we're here, lets change the mcmod.info to reflect our mod.







