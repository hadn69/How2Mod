How 2 minecraft mod the text document:

First go get urself a nice forge mdk from http://files.minecraftforge.net/
then extract it into a folder somewhere

Then delete everything deleted in this commit right here:
https://github.com/Shadows-of-Fire/How2Mod/commit/d55fbaa0f6d84c91f5114053fa302e4da9bcb0f7

Now you need to go actually get the gradle wrapper again, since you just deleted 2.14 (the very old version forge ships)
https://gradle.org/releases/ Go get yourself the binary-only edition of the latest gradle.
Since this is the actual version of gradle, you'll need to do a few things to use it.

You have two options here: Either install gradle to your system, or temporarily extract and generate the wrapper files.

Since the second option is less compilated, let's go with that.

So extract the gradle zip into some folder, then run the command "gradle w" from a command prompt or command line.
then run "gradle --stop" to close the daemon so you can delete this folder later.
Now you have generated 4 files you need to go put the wrapper back in your forge workspace.

gradlew
gradlew.bat
gradle (folder)

Move those three things into the dir with your mdk and then we can get back to that. (you can then delete the old gradle folder). See commit: https://github.com/Shadows-of-Fire/How2Mod/commit/e4ba4e1b92751816d7267780b8f84b759cc2757b

Then if you want a bit of understanding about the build.gradle, I've changed the default comments on them because they are useless. https://github.com/Shadows-of-Fire/How2Mod/blob/8b52990a88a6318e68a43d540754ff70ce5218a9/build.gradle

Now, there are a few things you need for this (one of them is a JDK, the other is an IDE).
If you dont have a JDK, you need to install it and properly configure it.
http://www.oracle.com/technetwork/java/javase/downloads/index.html
(I won't be going over that)
If you don't have an IDE, you need to go get one.  The only "supported" ones are IntelliJ IDEA and Eclipse.
I use eclipse, but this is a preference thing, so it really doesn't matter.
https://www.jetbrains.com/idea/download/ <- IntelliJ IDEA
https://www.eclipse.org/downloads/ <- Eclipse (giant Download 64 Bit button)

So now you have all those things you can actually start making a mod woo nice job
Back to the forge folder and run the command "gradlew sDecW eclipse" (for eclipse) or "gradlew sDecW idea" (for IDEA).
sDecW means setupDecompWorkspace (it's literally just the shorter command version, either works) and the second command makes certain IDE files.
sDecW will take a while, so just sit there and let it do stuff.  If it fails, it probably means your JDK is improperly configured.  The whole process is that this command downloads forge, the mappings, and minecraft.  It then decompiles minecraft, deobfuscates it (remaps most of the method and field names into readable ones), and then recompiles it so it can run in a dev environment, and creates a linked source jar for you to work with.  It's basically all magic.

Now here's the part where its important that I use eclipse, because if you're using IDEA, you'll have to figure out the idea equivalent of certain things I do.  *anyway* lets begin.

Now that your sDecW is finished (you should see a BUILD SUCCESSFUL) in the command window, you need to import the project into your IDE.  I think i'm gonna start using newlines here to split Eclipse and IDEA, in case anyone wants to write in here how that works.

ECLIPSE:  Use the import function and import an Existing Gradle Project.  Then just direct it to the folder containing your build.gradle and hit finish. Then you should end up with this: https://imgur.com/KLCwWmu

IDEA: ?

So now we basically just have the example mod in here. (com.example.examplemod.ExampleMod)
Which you can work with easily, but you should probably just completely ignore and make your own thing.

Before you delete the example mod, it might be useful to look at what is in it.  It's very basic, but it still has the important conceps that define a mod.

First off, the @Mod annotation, which marks your class as a main mod class for forge to load.
Now, there are 3 main variables you want to set in @Mod, being modid, version, and name.
the ExampleMod doesn't set name, so it defaults being your modid.
You'll also want to define all three of these as variables somewhere else, since you will need them in other places. (just as the example mod does).

It also has an @EventHandler for the init event, (you'll eventually have one for preInit, init, and postInit to do stuff).
Timing is very important with forge, so, the events are in place for a reason.

Okay so now delete the ExampleMod and it's package because those are useless and it doesn't matter.

So, now you want to create your own mod class.  If you made it this far you should already understand java naming convention, so pick a class name and a package and just poof make ur class.
Once you have that, update your group in your build.gradle to reflect this package name.

So now lets get to the @Mod annotation.

define 3 final strings in this class.  MODID, NAME, and VERSION.

	public static final String MODID = "how2mod";
	public static final String NAME = "How 2 Mod";
	public static final String VERSION = "1.0.0";
	
like so.

now create your @Mod annotation (this goes on the class).  In it, define modid, name, and version to be the three strings you just made. (Your version in here should probably reflect the one in your build.gradle)

The import is `net.minecraftforge.fml.common.Mod` if you get confused.

Your main mod class should now look similar to mine:
https://github.com/Shadows-of-Fire/How2Mod/blob/860899525689181cf2b8ac2d3de3c17da3757b65/src/main/java/shadows/how2mod/How2Mod.java

So now there are a few other things you need here.  First off, the @Instance annotation. For this, just define a blank public static variable of your mod class (public static How2Mod INSTANCE;) and throw @Instance above it.

Next up are proxies.  For proxies, you need at least two files, and if you need server-side only stuff, you need three.
There are a few ways to setup proxies, as your base proxy type can be a class or an interface, but here we'll use a class, since you won't have a special server proxy.
So create a new class named CommonProxy in a proxy subpackage.
Then, also make a ClientProxy class in the same package, that extends CommonProxy.
then, similarly to your @Instance, you need a blank CommonProxy field in your main mod class.
This field then needs to be annotated with @SidedProxy, and the two arguments need to be set as such.
clientSide = fully qualified name of your ClientProxy
serverSide = fully qualified name of your CommonProxy
See:
https://github.com/Shadows-of-Fire/How2Mod/commit/b4364ddd9f4aa846e3fa701b329d4e1f590ffb5f

Now we need some event handlers so we can actually do things with our new mod.

So now you need to create three @EventHandler methods.
(This is a special annotation used for FML lifecycle events, normal Forge events use @SubscribeEvent).

One for preInit(FMLPreInitializationEvent), one for init(FMLInitializationEvent), and one for postInit(FMLPostInitializationEvent).

These methods need to be non-static, and you need them in your main mod class.  You will also want similar methods in your proxies, but they do not need the annotation.
See:
https://github.com/Shadows-of-Fire/How2Mod/commit/b0c084dfc30863f6bffb43644e83865a0cee37a8

So now you're just about ready to make a block or an item or whatever.  But since automagic things are much better than writing out the same methods 100 times, lets setup a bit of a framework for doing things.
So make a new init package, and in there make a new class called ModRegistry.  Here is where we will define, register, and process new things that need to be registered with the game.  So lets start by making a new List<Block> and a new List<Item> (net.minecraft.item.Item and net.minecraft.block.Block)

	public static final List<Block> BLOCKS = new ArrayList<Block>();
	public static final List<Item> ITEMS = new ArrayList<Item>();
	
Now we also need two event handlers (simply put, a method with an Event as a param with @SubscribeEvent on it).
One for the Register<Block> event and one for the Register<Item> event.
In these, you want to call event.getRegistry().registerAll(List#toArray(new E[0])); for your respective lists.

	@SubscribeEvent
	public void onBlockRegister(Register<Block> event) {
		event.getRegistry().registerAll(BLOCKS.toArray(new Block[0]));
	}
	
	@SubscribeEvent
	public void onItemRegister(Register<Item> event) {
		event.getRegistry().registerAll(ITEMS.toArray(new Item[0]));
	}

Then, we need to go tell forge that this class exists and it has event handlers for forge to call.  let's do that in the CommonProxy (or the main mod class, doesn't matter, just so as long as you call it during preInit).
So, all you want to do here is call this method
MinecraftForge.EVENT_BUS.register(new ModRegistry());
in preinit, somewhere that will be called on both sides (So far, the only thing separated is your ClientProxy, which will only run code on the client).


Now i may seem like a crazy person and this may all seem pointless *but* there's just one more thing you should do.
Make a client package, and in it, create an interface named IHasModel.  This interface will only have one method (Yes, you can make it a default method, but i'll do that later, as the default impl is a bit complex.)

	@SideOnly(Side.CLIENT)
	public void registerModels();
	
That's it, thats the entire interface.  @SideOnly makes it so the method will not exist on the physical server.  And now for this interface to do work, we need to put it in one other location.  The ClientProxy.

So first off, call MinecraftForge.EVENT_BUS.register(this); in your client proxy's preinit method.

Then, create an event handler for the ModelRegistryEvent inside the client proxy.

	@SubscribeEvent
	public void onModelRegister(ModelRegistryEvent e) {
		
	}
	
Now in here, we need to loop through all our blocks and items, and if they are an IHasModel, call IHasModel#registerModels from them.

	for(Block b : ModRegistry.BLOCKS) if(b instanceof IHasModel) ((IHasModel) b).registerModels();
	for(Item i: ModRegistry.ITEMS) if(i instanceof IHasModel) ((IHasModel) i).registerModels();
	
Like so.



So now at this point you are finally ready to make a block/item.  Nice. Your workspace should resemble this repo at this commit: https://github.com/Shadows-of-Fire/How2Mod/tree/52c83bf11b620acf372bdcde06104857fd5c34df

Let's start with items, since items are about 3x easier than a Block to implement in the first place.

Make an items package, and create a class that extends Item.  Let's just call it ItemTest.

add a constructor that just takes a String, this string will be the item's registry name.

then in your constructor, you want to call 3 important methods.

	setRegistryName(name);
	setUnlocalizedName(How2Mod.MODID + "." + name);
	ModRegistry.ITEMS.add(this);

setRegistryName defines the namespace for your item, as all Items in minecraft now use this format, this step is required, or the game will crash.
setUnlocalizedName sets the unlocalized name and prefixes it with your modid for your lang file, you want to do this to avoid possible conflicts in lang keys.
The last call adds your item to your ITEMS list so it will be registered by the framework you set up earlier.

If you want your item to display in creative tab, you need to call setCreativeTab. You can use any vanilla tab, or your own, but for now let's just use CreativeTabs.MISC.

Your class should now look like this.

public class ItemTest extends Item {
	
	public ItemTest(String name) {
		setRegistryName(name);
		setUnlocalizedName(How2Mod.MODID + "." + name);
		setCreativeTab(CreativeTabs.MISC);
		ModRegistry.ITEMS.add(this);
	}

}

So now you want an item in the game, well you have your item class, and now you can make the most basic of item (that is, an item that exists, and does literally nothing).

To do this, simply define a new ItemTest in your ModRegistry after the lists.

	public static final Item TEST = new ItemTest("test");

You'll notice if you now run the game, you will see your item and it will have a missing texture.  That's because for it to have a texture, you need to implement IHasModel, and give it an item model JSON file.

So back to the ItemTest class.

Implement IHasModel, and then in registerModels(), call 

	ModelLoader.setCustomModelResourceLocation(this, 0, new ModelResourceLocation(getRegistryName(), "inventory"));
	
and now you need a JSON file, with your Item's registry name as its file name.  So off to the resources folder.

So, while we're here, lets change the mcmod.info to reflect our mod.  mcmod.info is a JSON file, so don't break the formatting.  If you're bad at JSON formatting, use a validator, such as https://jsonlint.com/
You should've changed it similarly to this: https://github.com/Shadows-of-Fire/How2Mod/commit/48d0c9c91775ed70eed5c975262ef9cc29886b52
Now back to making the Item model JSON.  Create a new folder named assets, inside that, a folder with your modid as the name (in this case, how2mod).
Then you need four other folders

	blockstates
	models
	lang
	textures
	
For now, ignore the blockstates folder.  In the lang folder, make an en_us.lang file (text document). A note about resources: case is important.  Any file with an uppercase letter will be ignored (completely just not loaded) during resource loading.
So no caps.
In the models folder, make a "block" and "item" folder.  The names are important.
In the textures folder, make a "blocks" and "items" folder.  Yeah, nice consistency mojang.

So now lets go to src\main\resources\assets\how2mod\models\item\ and make a new JSON file.  If you have no idea what a JSON is, it's basically a fancy-formatted text document with a bunch of rules.  
Since our item is named "test", we need a file named "test.json"
Now, you can use blockstates for items, but its obviously not always needed.  In this case, it wouldn't be worth it. Just copypaste this next part into your JSON.

{
  "parent": "item/generated",
  "textures": {
    "layer0": "items/sugar"
  }
}

What this does is parent the model to the vanilla model item/generated (the default item model)
and tells it to use the texture of sugar.  The name "layer0" for the texture is very important (basically all element names in json are extremely important, so don't misspell them, or you might rip your hair out wondering what's wrong).
Item models can have layers of textures, so layer0 says "put this texture on the lowest layer.

Also, you'll notice currently launching the mod doesn't register your item.  That's because you need to call super in all of your lifecycle events in your ClientProxy.
And before you actually launch the game, let's set the lang entry for your item.
in en_us.lang, define 
	item.how2mod.test.name=Test Item
The lang file works by taking key=name, where key is the lang key, and name is just about literally anything you can type there.  Lang entries are read per-line, so new entry, new line.

So now your item is ready (nice work).  Run the game using `gradlew runClient` from the command line, or by calling the runClient gradle task from within your ide (There are also launch configurations to run the game other ways.)
And your end result should basically be this: https://imgur.com/a/pjECs
Your repo should now resemble this repo at this point in time: https://github.com/Shadows-of-Fire/How2Mod/tree/7119010acf42c5f8dcca693d1561c71fe914f951

So, now you can make any basic item that doesn't do anything by creating a new ItemTest and giving it a model JSON and a lang entry.  If you want to use your own custom texture for your item, instead of "items/sugar", just define the path to your texture.

Item textures should go in textures/items, and to reference them you need to specify the domain.
The domain is your modid, vanilla textures do not requires a domain, as "minecraft" is the fallback domain.  You specify a domain as such.  Say you had a file "test.png" in textures/items.
	how2mod:items/test
that would be the string you provide to layer0 to use that texture.
So lets go make a bad looking 16x png to test this theory.

https://imgur.com/a/pvNea

See, bam, custom texture. See: https://github.com/Shadows-of-Fire/How2Mod/commit/4a0d6746954108cc2084182459e996239bd5b094

So now onto making a Block.  Make a new package called blocks and create a class extending Block (net.minecraft.block.Block) named BlockTest.
You'll notice automatically Block is not as simple as Item, as it has a required super constructor, taking a Material.  For now, just pass it Material.ROCK and ignore it.
The Material controls various things about the Block, and changing it will make it behave like you'd expect the material to.
Lets just add a constructor with a String for the name for now. We a;so want to implement IHasModel with a similar override to our item, but not exactly the same.

So this is now our block constructor.

	public BlockTest(String name) {
		super(Material.ROCK);
		setRegistryName(name);
		setUnlocalizedName(How2Mod.MODID + "." + name);
		setCreativeTab(CreativeTabs.MISC);
		ModRegistry.BLOCKS.add(this);
		ModRegistry.ITEMS.add(new ItemBlock(this).setRegistryName(getRegistryName()));
	}
	
the super sets the material.  The next four methods are the same from ItemTest. The last bit is creating an ItemBlock and adding that ItemBlock to the item list for registration.
The ItemBlock is needed for your Block to exist as an Item.  Blocks are strictly placed in the world.  Without an ItemBlock, it cannot be dropped, or held, or anything of the sort.

So now our constructor is explained, and lets implement IHasModel.
Oh yeah, and we're here right now: https://github.com/Shadows-of-Fire/How2Mod/commit/bfca6079737f91a7320adb5509024b143e2fd780
You should really be following these commits.

	@Override
	public void registerModels() {
		ModelLoader.setCustomModelResourceLocation(Item.getItemFromBlock(this), 0, new ModelResourceLocation(getRegistryName(), "inventory"));
	}
	
So sCMRL takes an item, but this is a block, so we need to use Item.getItemFromBlock to get this block's ItemBlock (the one we made in the constructor) to use it for the model location.
See, Models are special as they only exist for Items, blocks in-world are handled by Blockstates, which are mapped automatically based on the block's registry name (you can change this, but its not required).

So now we have that, let's define a new BlockTest.

	public static final Block TEST_BLOCK = new BlockTest("test_block");
	
Now that just sits it there and it gets put on all the nice lists for registration and everything.
Nice system as long as you remember to put the things on their lists.

So, now the thing needs a texture. For that, you need a blockstate. Which is another json file, which uses the registry name of the block, and goes in the blockstates folder.

This file is src\main\resources\assets\how2mod\blockstates\test_block.json

{
	"forge_marker": 1,
	"defaults": {
		"model": "cube_all",
		"textures": {
			"all": "blocks/stone"
		}
	},
	"variants": {
		"normal": [{}],
		"inventory": [{}]
	}
}

The forge_marker says this is a forge blockstate.
the defaults category is applied to all possible states of this block, in this case, only the normal state (variant) as it has no properties.
the model and textures are how the block is actually rendered.  In this case, "cube_all" is the default 6-side 1-texture block, and it's texture param is "all". The texture name is based on the model you're using, so keep that in mind.
The variants are where you define your blockstates, in this case, we only have the default (normal) and the inventory variant, which is the same as the normal.
The reason the inventory variant is used is that some blocks might need a different inventory model, and that allows for it.
But since we don't, we could use "normal" in the sCMRL of our BlockTest class instead of "inventory".
Either way, now starting up the game will have you a nice test block, but we should get a lang entry.


















